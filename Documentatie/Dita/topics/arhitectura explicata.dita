<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="strafer-liberator">
    <title>T</title>
    <topic id="launchers">
        <title>Launchers</title>
        <body>
            <p>Fiecare launcher determina rezolutia si setarile necesare sistemului pe care ruleaza,
                apoi instantiaza game class-ul Straferliberator din core</p>
        </body>
        <topic id="desktop-launcher">
            <title>Desktop Launcher</title>
            <body>
                <p>Configurari initiale,Functioneaza pe urmatoarele platforme:</p>
                <p>Windows</p>
                <p>Linux</p>
                <p>Mac OS</p>
            </body>
        </topic>
        <topic id="android-launcher">
            <title>Android Launcher</title>
            <body>
                <p>Configurari initiale, ascunde status bar-ul</p>
            </body>
        </topic>
    </topic>
    <topic id="touch-manager">
        <title>Touch Manager</title>
        <body>
            <p>Functioneaza doar atunci cand jocul e instantiat din Android Launcher</p>
            <p>Ascunde/ aduce in foreground controalele cu touch in timpul jocului.</p>
        </body>
    </topic>
    <topic id="worldrenderer">
        <title>WorldRenderer</title>
        <body>
            <p><xref
                    href="https://github.com/KOTerra/StraferLiberator/blob/portGreenfoot/strafer-liberator-master/core/src/com/game/straferliberator/render/WorldRenderer.java"
                    format="html" scope="external"
                        ><i>com.game.straferliberator.render.WorldRenderer.java</i></xref></p>
            <p>Primeste informatia furnizata de PaintManager pentru a randa fundalul si actorii, in
                ierarhia specificata, folosind Sprite Batch-ul.</p>
        </body>
    </topic>
    <topic id="sprite-batch">
        <title>Sprite Batch</title>
        <body>
            <p>Static, randeaza sprite-urile actorilor. Un sprite reprezinta o regiune dintr-o
                textura, aflate intr-un bounding box dreptunghiular.</p>
        </body>
    </topic>
    <topic id="screens">
        <title>Screens</title>
        <body/>
        <topic id="id_ttt_xxq_g5b">
            <title>Loading Screen</title>
            <body>
                <p>In el sunt definite toate asseturile incarcate de AssetManager. O bara de loading
                    afiseaza progresul iar ecranul este schimbat in game screen cand toate
                    asset-urile sunt incarcate.</p>
            </body>
        </topic>
        <topic id="game-screen">
            <title>Game Screen</title>
            <body>
                <p>Instantiaza WorldRenderer -ul, apeleaza dispose pentru a elibera obiecte
                    nefolosite din memorie, actualizeaza variabila elapsed si FPS din WorldData
                    pentru operatiile ce tin evidenta timpului si itereaza prin toti actorii din
                    PlayWorld pentru a apela metoda act()</p>
            </body>
        </topic>
    </topic>
    <topic id="asset-manager">
        <title>Asset Manager</title>
        <body>
            <p>O clasa din libGDX care permite incarcarea de asseturi in memorie pe un alt thread
                fata de cel principal(GLThread). Acestuia i se seteaza loadere definite pentru
                clasele jocului si pot fi referentiate dupa aceea cu o funtie get(). AssetManagerul
                elimina timpii de load si memoria ocupata de obiecte ce nu sunt necesare, lucru ce
                nu putea fi realizat cu Greenfoot.</p>
        </body>
        <topic id="asset-loaders">
            <title>Asset Loaders</title>
            <body>
                <p>Implementeaza AsynchronousAssetLoader, avand definit tipul de clasa pe care
                    trebuie sa il returneze si parametrii specifici unde este cazul</p>
                <p>
                    <ul id="ul_adb_w1r_g5b">
                        <li>AnimationLoader</li>
                        <li>FontLoader</li>
                        <li>GifImageLoader</li>
                        <li>GreenfootImageLoader</li>
                        <li>GreenfootSoundLoader</li>
                    </ul>
                </p>
            </body>
        </topic>
    </topic>
    <topic id="paint-manager">
        <title>Paint Manager</title>
        <body>
            <p>Contine un array de tip Class&lt;?>[] paintOrder in care este stocata ierarhia pe
                care WorldRenderer ul o respecta atunci cand apeleaza draw pentru actori. Pentru
                clasele ce nu sunt adaugate in ierarhie se verifica recursiv daca obiectul verificat
                este instance al unei clase din paintOrder. Nivelurile acestui arbore format sunt
                stocate intr-un hashmap <i>classPaintIndex</i> ca valoare , cheia fiind tipul
                clasei, iar in alt hashmap <i>objectsInPaintOrder</i> avem cheie nivelul arborelui
                iar valorile array uri cu obiectele de pe acel nivel. Arborele este actualizat cand
                un Actor este adaugat sau sters din world. </p>
        </body>
    </topic>
    <topic id="greenfoot">
        <title>Greenfoot</title>
        <body>
            <p>Pachetul cu clase wrapper care adapteaza API-ul Greenfoot</p>
        </body>
        <topic id="actor">
            <title>Actor</title>
            <body>
                <p>Extinde gdx.Image, care la randul lui este o subclasa a gdx.Actor. Atat pentru
                    libGDX cat si pentru Greenfoot un actor este un sprite care exista intr-un
                    World/Stage si poate avea coliziuni si pozitie in spatiu. Un greenfoot.Actor
                    primeste ca textura un GreenfootImage, bounding box-ul fiind calculat in functie
                    de dimensiunile imaginii, pozitia(in pixeli) fiind punctul din centrul
                    imaginiii.</p>
            </body>
        </topic>
        <topic id="world">
            <title>World</title>
            <body>
                <p>Extinde gdx.Stage. In ambele situatii, Stage/World reprezinta clasele ce contin
                    toti actorii si informatii despre locatiile si coliziunile dintre ei. Un
                    GameScreen trebuie sa aiba un World in componenta.</p>
            </body>
        </topic>
        <topic id="greenfootimage">
            <title>GreenfootImage</title>
            <body>
                <p>Clasa utilizata de Greenfoot pentru a textura actorii sau background-ul din
                    world. Extinde gdx.TextureRegion. De asemenea are functionalitati de randat
                    forme geometrice, text sau alte GreenfootImage-uri in interiorul unui
                    GreenfootImage. Aceste functionalitati sunt implementate folosind
                    Pixmap,Bitmap,FrameBuffer-uri. Exista si functionalitati de baza precum setarea
                    transparentei sau scalare.</p>
            </body>
        </topic>
        <topic id="font">
            <title>Font</title>
            <body>
                <p>Extinde gdx.BitmapFont. Este folosit pentru a randa Stringuri in obiecte
                    GreenfootImage. Deoarece un Bitmap consuma foarte multa memorie, exista un
                    singur font static utilizat de toate clasele.</p>
            </body>
        </topic>
        <topic id="greenfootsound">
            <title>GreenfootSound</title>
            <body>
                <p>Are functionalitati simple de pornit sau manipulat fisiere audio. </p>
            </body>
        </topic>
        <topic id="greenfoot-1">
            <title>Greenfoot</title>
            <body>
                <p>Clasa de utilitati ce se ocupa in principal de detectarea inputului de la mouse
                    sau tastatura.</p>
            </body>
        </topic>
        <topic id="mouseinfo">
            <title>MouseInfo</title>
            <body>
                <p>Tine cont de pozitia cursorului pe ecran si de care dintre butoanele acestuia
                    sunt apasate.</p>
            </body>
        </topic>
    </topic>
    <topic id="game">
        <title/>
        <topic id="playworld">
            <title>PlayWorld</title>
            <body>
                <p>Este un World ce contine toate sistemele de joc si un player si este legat la
                    WorldListener.</p>
                <ul>
                    <li><p>World Sections</p>Fiind<ul>
                            <li>
                                <p>WorldStructure</p>
                                <p>Un WorldStructre este un actor dintr- o sectiune care se ocupa de
                                    limitele lumii si de coliziunile dintre ea si Actori</p>
                                <ul>
                                    <li>
                                        <p>Walls</p>
                                        <p>Peretii invizibili sunt verticali si orizontali, primind
                                            in constructor directia pe care trebuie sa verifice si
                                            sa rezolve coliziunile cu un Entity.</p>
                                    </li>
                                    <li>
                                        <p>Door</p>
                                        <p>O usa ce blocheaza accesul intr- o anume zona. Poate fi
                                            deschisa sub o conditie definita.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>map matrix</p>
                            </li>
                            <li>
                                <p>Events</p>
                            </li>
                            <li>
                                <p>Npc placement</p>
                            </li>
                        </ul></li>
                    <li><p>Scroller</p>
                        <p>Scroller-ul este o clasa ce tine evidenta pozitiei playerului in lume si
                            actualizeaza background-ul , dar si pozitia actorilor relativi la
                            pozitia playerului astfel incat lumea de joc sa nu fie limitata la
                            viewport, iar playerul sa fie constant in mijlocul ecranului atat timp
                            cat nu este in marginea sectiunii. Scrollerul are 2 variabile statice
                            prin care se tine evidenta pozitiei globale a actorilor
                            (scrolledX,srolledY).</p></li>
                    <li><p>WorldListener</p>
                        <p>WorldListener-ul comunica cu scrollerul si playerul, avand rolul de a
                            tine logica din spatele conexiunilor intre WorldSection-uri si de a
                            decide cand si cum acestea trebuie schimbarte. Metoda changeWorldSection
                            seteaza pozitia playerului in functie de latura in care sunt
                            intersectate sectiunile, iar apoi incarca fundalul din assetManager,
                            sterge din PlayWorld entitatile si adauga entitatile specifice sectiunii
                            in care a intrat plahyerul. Schimbarea aceasta nu necesita loading
                            screenuri.</p>
                        <p> </p></li>
                    <li><p>Entities</p>
                        <p>Un Entity este un Actor care respecta regulile Scroller-ului si poate
                            interactiona cu alti actori de tip Entity</p><ul>
                            <li><p>Iteme</p>
                                <p>Item-ul este un obiect detinut de Player sau de NPC-uri. Pot fi
                                    atasate de Actorul care il detine sau pot fi de tip PickUp(sunt
                                    ridicate de Player)</p></li>
                            <li><p>Movers</p>
                                <p>Un Mover este un Entity ce se poate misca si are coliziune cu
                                    pereti si alti Moveri, este de 2 tipuri :</p><ul>
                                    <li><p>Player</p>
                                        <p>Actorul ce trebuie sa existe constant in PlayWorld.
                                            Playerul controleaza Scroller-ul prin pozitia sa si
                                            modifica scrolledX scrolledY. Acesta proceseaza inputul
                                            si face actiuni corespunzatoare: se misca, isi schimba
                                            viteza, da toggle unui meniu, foloseste un item.</p><ul>
                                            <li><p>Health/Stamina Bar</p>
                                                <p>sunt cele 2 elemente din HUD ce arata nivelul de
                                                  hit points / stamina ramas. Se actualizeaza in
                                                  functie de cat damage primeste Playerul sau cata
                                                  stamina foloseste in timp ce se misca cu
                                                  sprint</p></li>
                                            <li><p>Inventory</p>
                                                <p>Se activeaza cu tasta E sau apasand butonul
                                                  dedicat pe Android. Acesta arata ce Iteme sunt
                                                  deblocate de player(cele obtinute cu PickUp). Pot
                                                  fi selectate cu click stanga si deselectate cu
                                                  click dreapta.</p></li>
                                            <li><p>Knockback</p>
                                                <p>O metoda prin care un mover este impins in
                                                  directia opusa atunci cand o forta este aplicata
                                                  asupra lui. In general se foloseste pentru a
                                                  rezolvaa coliziuni intre Iteme care dau damage de
                                                  tip melee si NPC-uri sau Player. Se folosesc
                                                  formule de mecanica clasica si trigonometrie de
                                                  baza.</p></li>
                                        </ul></li>
                                    <li><p>NPC</p>
                                        <p>NPC(Non playable character) sunt orice alt Entity care nu
                                            este Player. Se clasifica in 2 tipuri:</p><ul>
                                            <li><p>Friendly</p>
                                                <p>Apare pe harta in functie de eventurile din
                                                  EventSystem si initiaza un anumit dialog atunci
                                                  cand Playerul il atinge. Are mereu stare de
                                                  idle.</p></li>
                                            <li><p>Hostile</p>
                                                <p>Un NPC Hostile are scopul de a urmari si ataca
                                                  Playerul cand se afla in raza sa de acoperire. </p><ul>
                                                  <li><p>Pathfinding</p>
                                                  <p>In spatele pathfindingului si urmaririi se afla
                                                  o implementare a algoritmului Breadth First Search
                                                  aplicat pe matricea fiecarui WorldSection. Cu
                                                  acesta se calculeaza cel mai scurt drum care evita
                                                  tile-urile marcate cu -1 in matrice, iar ordinea
                                                  de pasi ce trebuie facuti prin tile-urile pana la
                                                  Player se salveaza intr-o coada de directii</p></li>
                                                  <li>
                                                  <p>Combat</p>
                                                  <p>atunci cand Playerul este in proximitatea
                                                  NPC-urilor, fiecare tip de Hostile intra intr-un
                                                  state de combat in care ataca Player-ul in modul
                                                  specific clasei. I se aplica damage si knockback
                                                  in cazul in care e atacat de Player.</p>
                                                  </li>
                                                </ul></li>
                                        </ul></li>
                                </ul></li>
                        </ul></li>
                </ul>
            </body>
        </topic>
        <topic id="file-loaders">
            <title>File Loaders</title>
            <body>
                <p>Clasele Loader si DialogLoader contin metode ce incarca fisierele in care sunt
                    stocate date din folderele:</p>
                <ul>
                    <li><p>saves</p></li>
                    <li><p>dialogs</p></li>
                    <li><p>maps</p></li>
                </ul>
            </body>
        </topic>
        <topic id="systems">
            <title>Systems</title>
            <body>
                <p>Pentru a putea avea un storyline cu eventuri predefinite si stari dinamice ale
                    jocului a fost nevoie de implementarea mai multor sisteme</p>
                <ul>
                    <li><p>SaveSystem</p>
                        <p>Salveaza in anumite momente toate datele necesare pentru a continua jocul
                            dupa un restart al aplicatiei. Acesta incarca in WorldData : locatia si
                            viata player-ului, sectiunea in care se afla, sectiunile deblocate,
                            obiectivele, event-ul curent, item-ele deblocate si npc-urile
                            cunoscute.</p></li>
                    <li>
                        <p>EventSystem</p>
                        <p>Acesta contine cronologia eventurileor(sau questurilor) din povestea
                            jocului. Parcurgerea lor schimba comportamentul PlayWorld-ului in raport
                            cu Playerul, inserand sau eliminand din lume obiecte unice doar pentru
                            acel event(ex un item/ un NPC cu un anume dialog) . Fiecare event are un
                            numar ce este salvat in WorldData.</p>
                    </li>
                    <li><p>MusicSystem</p>
                        <p>Exista 3 melodii in joc: una pentru meniurile de pauza si altele doua
                            pentru gameplay loop. Cele pentru gameplay loop sunt actualizate dinamic
                            in functie de ceea ce face playerul. cu un delay de cateva secunde este
                            determinat daca playerul este in stare de combat sau de explorare si
                            schimba intre muzica combat si idle. in timpul momentelor de cutscene,
                            dialog sau tutorial muzica este oprita.</p></li>
                    <li><p>Dialog System</p>
                        <p>Sistemul de dialoguri a fost introdus pentru a da informatie contextuala
                            playerului fara a intrerupe gameplayul prea des cu cutsceneuri. Acesta
                            sta pe baza NPC urilor friendly si are un design clasic de RPG.</p></li>
                </ul>
            </body>
        </topic>
        <topic id="graphics">
            <title>Graphics</title>
            <body>
                <p>Pe langa clasele rudimentare oferite de Greenfoot, a trebuit sa implementam alte
                    clase pentru control grafic</p>
                <ul id="ul_z43_chz_g5b">
                    <li>
                        <p>Picture</p>
                        <p>Este un actor fara coliziune cu scopul de a fi o simpla imagine care in
                            general este utilizata ca o componenta de UI</p>
                    </li>
                    <li>
                        <p>Text</p>
                        <p>La fel ca Picture, aceasta clasa este un element de UI care doar da
                            display unui text</p>
                    </li>
                    <li><p>GifImage</p>O clasa care primeste un gdx.Array(GreenfootImage) si o
                        durata a frame-urilor in milisecunde. Clasa are metode ce returneaza toate
                        frame-urile, frame-ul ce trebuie afisat la un moment de timp calculat in
                        fucnctie de variabila WorldData.elapsed.<ul id="ul_ap3_chz_g5b">
                            <li>
                                <p>GifDecoder</p>
                                <p>O clasa ce citeste un fisier .gif  si formeaza un GifImage</p>
                            </li>
                            <li>
                                <p>Animation</p>
                                <p>Un animation este o clasa cu un GifImage ce poate rula pentru un
                                    numar limitat de ori .</p>
                                <ul id="ul_bp3_chz_g5b">
                                    <li>
                                        <p>AnimationRunner</p>
                                        <p>Primeste un animation si un actor care trebuie animat.
                                            Este nevoie de un runner pentru ca fiecae animation este
                                            unic in asset manager si nu poate fi rulat intern pentru
                                            mai multi actori de acelasi tip.</p>
                                    </li>
                                    <li>
                                        <p>Transition</p>
                                        <p>Un animaton cu scop similar ca Picture si Text</p>
                                    </li>
                                </ul>
                            </li>
                        </ul></li>
                </ul>
            </body>
        </topic>
        <topic id="user-interface">
            <title>User Interface</title>
            <body>
                <p>UI- ul se imparte intre meniuri si HUD(heads up display), diferenta fiind ca HUD
                    ul este afisat in timpul gameplay loopului, iar meniurile cand
                    WorldData.PAUZA=true</p>
                <ul>
                    <li><p>Meniuri</p>
                        <p>
                            <ul id="ul_zbz_4kz_g5b">
                                <li>Main Menu - meniul care apare cand se intra in GameScreen, are
                                    un buton Continue si unul New</li>
                                <li>Pause Menu - este accesat in timpul jocului prin tasta esc sau
                                    pe android prin butonul dedicat. Are butoanele Resume, Map,
                                    MainMenu</li>
                                <li>Map Menu- accesat din Pause Menu. Afiseaza sectiunile deblocate
                                    din harta, obiectivele si pozitia playerului</li>
                                <li>Tutoriale - explica anumite aspecte pentru mecanici/npc/items </li>
                                <li>Cutscene-uri - in esenta tot tutoriale dar au scop in
                                    dezvoltarea vizuala a povestii</li>
                            </ul>
                        </p></li>
                    <li>HUD  - inventory, healthbar, staminabar</li>
                    <li><p>Butoane - Butoanele din UI sunt compatibil atat cu mouse-ul pe desktop cat si cu touchscreen.
                            Fiecare tip de buton are intregul behaviour definit, butoanele
                            actualizandu-se diferit pentru fiecare meniu</p></li>
                    <li><p>Touch Controls</p>Sunt controalele specifice pentru Android. apar pe
                        ecran atunci cand WorldData.PAUZA=false si se actualizeaza la fel dinamic in
                        functie de ce actiuni sunt disponibile playerului   (Dpad si sprint pentru
                        miscarea playerului, inventory pt a accesa inventory-ul, butonul de pauza si
                        butoanele dedicate pentru controlul itemelor) </li>
                </ul>
            </body>
        </topic>
        <topic id="worlddata">
            <title>WorldData</title>
            <body>
                <p>Contine o multitudine de field-uri si metode statice ce sunt accesate atat la
                    inceput cat si in timpul jocului. Aici sunt incarcate datele din fisierele de
                    salvare, sunt actualizate variabilele legate de frame-rate, metodele necesare
                    pentru sistemul de eventuri si cel de dialoguri, pentru pathfinding si pentru
                    setarile initiale ale rezolutiei.</p>
            </body>
        </topic>
    </topic>
    <topic id="mapgenerator">
        <title>MapGenerator</title>
        <body>
            <p><b><i><xref
                            href="https://github.com/KOTerra/StraferLiberator/tree/portGreenfoot/mapGenerator/Mapgenerator/MapGen"
                            format="html" scope="external"
                        >/mapGenerator/Mapgenerator/MapGen</xref></i></b></p>
            <p>Un tool ce ne ajuta sa automatizam generarea de obiecte ce sunt adaugate in
                PlayWorld, cat si matricele asociate pathfindingului in fiecare WorldSection</p>
            <p>Fiecare WorldSection a fost construit multi-layered in <b>Tiled</b> cu tile-uri de
                64*64pixeli prezente ca tileset-uri Ã¯n <b><i><xref
                            href="https://github.com/KOTerra/StraferLiberator/tree/portGreenfoot/mapGenerator/TiledMaps"
                            format="html" scope="external"
                        >mapGenerator\TiledMaps\tilesets</xref></i></b>. Acest lucru ne permite sa
                modificam foarte usor harta si ceea ce se afla pe ea dintr-un GUI. Apoi acestea sunt
                exportate in format JSON in folderul "mapGenerator/TiledMaps". Cand aplicatia este
                rulata, un dialog windows pentru selectie de fisiere este deschis penttru a alege ce
                fisier vrem sa parsam in consola avem 2 optiuni disponibile:</p>
            <p>1. Pentru a genera matricea de pathfinding</p>
            <p>1. pentru a genera cod java cu functii init() ce poate fi inserat direct in clasele
                WorldSection&lt;11-23></p>
            <p>Output-ul este salvat in fisiere .txt, iar apoi adaugate in core project.</p>
            <p>Aplicatia a fost scrisa in C++17 , iar parsarea s-a realizat cu libraria Tileson</p>
        </body>
        <topic id="tiled-maps">
            <title>Tiled Maps</title>
            <body>
                <ul>
                    <li><p>TIleson</p><ul>
                            <li><p>Pathfind matrix</p></li>
                            <li><p>World Structure generation</p></li>
                        </ul></li>
                </ul>
            </body>
        </topic>
    </topic>
</topic>
